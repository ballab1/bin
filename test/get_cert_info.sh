#!/usr/bin/bash -x

#------------------------------------------------------------------------------------
function ::collect_info() {
    local -r mode="${1:?}"
    local -r k8s_dir='/var/snap/microk8s/current'

    mkdir -p "${WORKDIR}/$mode"
    cd "${WORKDIR}/$mode" ||:


    kubectl cluster-info dump > 'cluster-info.txt'
    ::splitClusterInfo "${WORKDIR}/$mode/cluster-info.txt"

    sudo microk8s inspect
    sudo mv "${k8s_dir}"/inspection-report-*.tar.gz .
    sudo chown bobb:users inspection-report-*.tar.gz
    tar xzf inspection-report-*.tar.gz

    for dir in 'args' 'certs' 'credentials'; do
        mkdir -p "${dir}" ||:
        sudo cp -r "${k8s_dir}/${dir}"/* "$dir"/
        sudo chown -R bobb:users "$dir"
    done
    for crt in certs/*.crt; do
        openssl x509 -in "$crt" -noout -text > "$crt".inf
    done

    local cfg_map='extension-apiserver-authentication.json'
    kubectl get configmap -n kube-system extension-apiserver-authentication -o json > "$cfg_map"
    while read -r key; do
        jq -r ".data.\"$key\"" "$cfg_map" > "${key}.txt"
    done < <(jq -r '.data|keys[]' "$cfg_map")
    for crt in *'-ca-file.txt'; do
        local name="${crt%-ca-file*}"
        mv "$crt" "$name"
	awk -v fname="$name" '
/-----BEGIN CERTIFICATE-----/{
  crt = fname ".p" ++n ".crt"
}
crt {print > crt}
/-----END CERTIFICATE-----/{
   close(crt)
   cmd = "openssl x509 -noout -text -in " crt " > " crt ".inf"
   system(cmd)
   crt = ""
}' "$name"
        mv "$name" "${name}.crt"
#        for file in "${name}.p"*'.crt'; do
#            openssl x509 -noout -text -in "$file" > "${file}.inf"
#        done
    done

    cd "$HOMEDIR" || exit
}

#------------------------------------------------------------------------------------
function ::main() {

    local -r HOMEDIR='/home/bobb/workspace'
    local -r WORKDIR="${HOMEDIR}/certs-info"

    cd "$HOMEDIR" || exit
    [ -d "$WORKDIR" ] && sudo rm -rf "$WORKDIR"
    mkdir -p "$WORKDIR"
    cp "${HOMEDIR}/certs"/* "$WORKDIR"

    "${HOMEDIR}/reinstall.cluster"
    microk8s config | sed -e 's|micro|dev|g' > current/config.devk8s.home
    sleep 180
    ::collect_info 'config.map.org'


    sudo microk8s refresh-certs 'certs/'
    microk8s config | sed -e 's|micro|dev|g' > current/config.devk8s.home
    cp current/config.devk8s.home ~/.kube/config
    sleep 180
    ::collect_info 'config.map.home'


    sudo microk8s refresh-certs -u
    microk8s config | sed -e 's|micro|dev|g' > current/config.devk8s.home
    cp current/config.devk8s.home ~/.kube/config
    sleep 180
    ::collect_info 'config.map.s5'


    sudo microk8s refresh-certs 'certs/'
    microk8s config | sed -e 's|micro|dev|g' > current/config.devk8s.home
    cp current/config.devk8s.home ~/.kube/config
    sleep 180
    ::collect_info 'config.map.home-2'


    sudo microk8s refresh-certs -u
    microk8s config | sed -e 's|micro|dev|g' > current/config.devk8s.home
    cp current/config.devk8s.home ~/.kube/config
    sleep 180
    ::collect_info 'config.map.s5-2'


    # now tar up everything
    cd "$WORKDIR" ||:
    tar -czf "${WORKDIR}.tgz" ./*
    sudo rm -rf "$WORKDIR"
}

#------------------------------------------------------------------------------------
function ::splitClusterInfo() {
    # Script generated by AI from the following prompt:
    #
    #   I have a file containing several sections:
    #
    #   The first section is a JSON blob '{.......}'. This should be saved as 'cluster.cfg.json'.
    #
    #   There are then multiple sections which are delimited with the lines:
    #   ==== START logs for container <TYPE> of pod <NS>/<ID> ====
    #   ==== END logs for container <TYPE> of pod <NS>/<ID> ====
    #   Each of these sections should be saved as NS_ID.log
    #
    #   The last section is another JSON blob '{.....}{....}{....}'. This should be saved as 'cluster.info.json'
    #
    #   The first JSON blob should contain everything from the first line of my input file up until, but excluding, the first line of the first log section.
    #   The last JSON blob should contain everything from the line after the last log section to the end of the input file
    #
    #
    #   Using BASH, create a script which will split my file, by section, into individual files


    local -r input_file="${1:?}"
    local -r dir="$(dirname "$input_file")"
    local -r state_json="${dir}/cluster.state.json"
    local -r info_json=" ${dir}/cluster.info.json"

    # Extract cluster.cfg.json (everything up to the first log section)
    awk '/^==== START logs for container/ {exit} {print}' "$input_file" > "$state_json"

    # Extract log sections
    awk '
        /^==== START logs for container/ {
            split($0, arr, "[ /]")
            log_file = arr[6] "__" arr[9] "__" arr[10] ".log"
            print NR ":  " log_file
        }
        log_file {print > log_file}
        /^==== END logs for container/ {
            close(log_file)
            log_file = ""
        }
    ' "$input_file"

    # Extract cluster.info.json (everything after the last log section)
       # Find the last occurrence of an END log delimiter
    local last_end_line=$(grep -n "==== END logs for container" "$input_file" | tail -n 1 | cut -d: -f1)

    # Extract content after the last log section
    if [ -n "$last_end_line" ]; then
        sed -n "$((last_end_line + 1)),\$p" "$input_file" > "$info_json"
    else
        echo "No log sections found."
        touch "$info_json"
    fi
}

#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------


::main
exit
